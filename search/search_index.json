{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ready to Code? Find beginner programming tutorials right here! Learn how to code in python !","title":"Home"},{"location":"#ready-to-code","text":"Find beginner programming tutorials right here! Learn how to code in python !","title":"Ready to Code?"},{"location":"about/","text":"About Westview Arduino Club is a club meant to introduce students to programming and hardware. We hope to allow students to work on projects with each other in a manner that they may not have before; forming project ideas together, brainstorming solutions, and more. Here, regardless of whether you are experienced at programming and hardware or not, you'll be able to get help and give help to others in a safe, kind environment. Members Thanks to our (on-github) club members, some of which contributed here: Can I contribute? Sure! Submit a pull request here and follow the instructions listed in the README. The Poway Unified School District (PUSD) is an equal opportunity employer/program and is committed to an active Nondiscrimination Program. PUSD prohibits discrimination, harassment, intimidation, and bullying based on actual or perceived race, color, ancestry, national origin, nationality, immigration status, ethnicity, ethnic group identification, age, religion, marital or parental status, physical or mental ability, sex, sexual orientation, gender, gender identity, or gender expression or association with a person or a group with one or more of these actual or perceived characteristics. For more information, please contact: Title IX/Equity Compliance Officer, James Jimenez, Associate Superintendent of Personnel Support Services, Poway Unified School District, 15250 Avenue of Science, San Diego, CA 92128, 1-858-521-2800, extension 2761, jjimenez@powayusd.com","title":"About"},{"location":"about/#about","text":"Westview Arduino Club is a club meant to introduce students to programming and hardware. We hope to allow students to work on projects with each other in a manner that they may not have before; forming project ideas together, brainstorming solutions, and more. Here, regardless of whether you are experienced at programming and hardware or not, you'll be able to get help and give help to others in a safe, kind environment.","title":"About"},{"location":"about/#members","text":"Thanks to our (on-github) club members, some of which contributed here:","title":"Members"},{"location":"about/#can-i-contribute","text":"Sure! Submit a pull request here and follow the instructions listed in the README. The Poway Unified School District (PUSD) is an equal opportunity employer/program and is committed to an active Nondiscrimination Program. PUSD prohibits discrimination, harassment, intimidation, and bullying based on actual or perceived race, color, ancestry, national origin, nationality, immigration status, ethnicity, ethnic group identification, age, religion, marital or parental status, physical or mental ability, sex, sexual orientation, gender, gender identity, or gender expression or association with a person or a group with one or more of these actual or perceived characteristics. For more information, please contact: Title IX/Equity Compliance Officer, James Jimenez, Associate Superintendent of Personnel Support Services, Poway Unified School District, 15250 Avenue of Science, San Diego, CA 92128, 1-858-521-2800, extension 2761, jjimenez@powayusd.com","title":"Can I contribute?"},{"location":"python-tutorials/Setup/","text":"Python Setup Learn the basics of python! How do I start? There are two popular ways to run python: on a browser, or locally on your computer. On a browser: We recommend CodeSkulptor because it is easy to use and has lots of available modules (you'll learn about that later!) If you don't like CodeSkulptor, simply look up \"web python ide\" and something good should pop up. On your computer (local): Install python3 Install an editor that can run python3 i.e. don't use the command line. VSCode with the python extension works well. What if I'm not in Arduino Club? Don't worry about it! Just have fun, and if you like this tutorial, \"star\" our project on github \ud83d\ude0a. Can I contribute? Sure! Submit a pull request here and follow the instructions listed in the README. Creators Sean Boerhout","title":"Setting up python"},{"location":"python-tutorials/Setup/#python-setup","text":"Learn the basics of python!","title":"Python Setup"},{"location":"python-tutorials/Setup/#how-do-i-start","text":"There are two popular ways to run python: on a browser, or locally on your computer. On a browser: We recommend CodeSkulptor because it is easy to use and has lots of available modules (you'll learn about that later!) If you don't like CodeSkulptor, simply look up \"web python ide\" and something good should pop up. On your computer (local): Install python3 Install an editor that can run python3 i.e. don't use the command line. VSCode with the python extension works well.","title":"How do I start?"},{"location":"python-tutorials/Setup/#what-if-im-not-in-arduino-club","text":"Don't worry about it! Just have fun, and if you like this tutorial, \"star\" our project on github \ud83d\ude0a.","title":"What if I'm not in Arduino Club?"},{"location":"python-tutorials/Setup/#can-i-contribute","text":"Sure! Submit a pull request here and follow the instructions listed in the README.","title":"Can I contribute?"},{"location":"python-tutorials/Setup/#creators","text":"Sean Boerhout","title":"Creators"},{"location":"python-tutorials/lesson1/","text":"The Basics Created By: Sean Boerhout Variables and Data Types So where do we start? Well, nearly all programming involves variables , or snippets of memory in your computer that holds some data. Say I wanted to take user input, or record the number of times someone pressed a button. You'd need variables to do this! Let's start with a simple example: the number of minecraft worlds I have on my computer to date, which is 27. minecraft_world_count = 27 Here, minecraft_world_count is my variable, and it holds a number (an integer to be exact). Different types of data need to be held with different types of variables; for example, 1.1 isn't an integer anymore, it's a rational number (in coding terms, a floating-point number). Another cool thing in python is that you can easily represent large numbers. Whenever you assign a number to a variable, you can't use commas to make it easily readable. For example, myNumber = 100 , 000 Will actually cause python to think that your number is of type tuple , which is a data type that doesn't allow you to change its value. To tell python that the number is still an integer you can do this: my_number = 100_00 Printing Now, suppose I wanted to print the value of a variable as an output. Python has a useful function called print() for this, so print ( myNumber ) will output 100000 . If I wanted to combine a string with the number, all you need to do is pass another argument (what print() will print) to print() . print ( \"My number is \" , myNumber ) Output: My number is 100000 One more thing: what if we wanted to format a string into different parts i.e. number here, string there without using commas? Python allows us to do this super easily too: print ( f \"My number is { myNumber } \" ) Output: My number is 100000 Python recognizes that you wanted a formatted string by prefixing the string with an f . Then you can use curly braces to say where you want the number! (You'll see how awesome this is in future lessons). Strings Say I wanted to give my favorite world a name, and hold that name in a variable. I could do it like this: minecraft_world_name = \"Zombie manhunt\" And in this case, the variable would be of type string . In python, strings are neat because you can add characters to them like this: my_name = \"Bill\" my_full_name = my_name + \" Mitchell\" print ( my_full_name ) Output: Bill Mitchell There are also some cool methods to modify strings: upper() Makes a string uppercase rock = \"let's rock\" print ( rock . upper ()) Output: LET'S ROCK lower() Makes a string lowercase fruit = \"APPLES\" print ( fruit . lower ()) Output: apples title() Capitalizes a string my_name = \"bill mitchell\" print ( my_name . title ()) Output: Bill Mitchell Booleans One more example: suppose I wanted to say whether python is cool. I could use a boolean type variable: python_is_awesome = True Type Function If you ever want to know what the type of something is, then you can use a function called type() . This outputs the type of the variable: print ( type ( 1 )) print ( type ( 1.1 )) print ( type ( 1000000000 )) print ( type ( \"one\" )) print ( type ([ 1 , 2 , 3 , 4 ])) # Coming next lesson! Output: < type 'int' > < type 'float' > < type 'int' > < type 'str' > < type 'list' > Basic Arithmetic So... pure variables are boring - you've probably figured that out by now. Can we modify them? In fact, yes! And it's super easy. Whenever you modify a variable, python essentially overrides one of the variables. Say I just made a new minecraft world. To add another world, I'd just do: minecraft_world_count = minecraft_world_count + 1 Super easy! Since programmers use this kind of arithmetic very often, however, there is shorthand notation for this: minecraft_world_count += 1 += # variable = variable + increment -= # variable = variable - increment *= # variable = variable * increment /= # variable = variable / increment Commenting What if you have code and you want to write a description about it? Just writing next to it won't work because python will think that you're still trying to code. In this case, you can use comments . Simply prefix any words/sentences/phrases with a hashtag: # . For bulk commenting, you can use three quotes. Example: # My name is Zephyr: print ( \"My name is Zephyr!\" ) \"\"\" Do you like striders in minecraft? I do... they are fun, but could use more health. On a scale of 1-10, this is how much I like striders: \"\"\" print ( 7 )","title":"The Basics"},{"location":"python-tutorials/lesson1/#the-basics","text":"Created By: Sean Boerhout","title":"The Basics"},{"location":"python-tutorials/lesson1/#variables-and-data-types","text":"So where do we start? Well, nearly all programming involves variables , or snippets of memory in your computer that holds some data. Say I wanted to take user input, or record the number of times someone pressed a button. You'd need variables to do this! Let's start with a simple example: the number of minecraft worlds I have on my computer to date, which is 27. minecraft_world_count = 27 Here, minecraft_world_count is my variable, and it holds a number (an integer to be exact). Different types of data need to be held with different types of variables; for example, 1.1 isn't an integer anymore, it's a rational number (in coding terms, a floating-point number). Another cool thing in python is that you can easily represent large numbers. Whenever you assign a number to a variable, you can't use commas to make it easily readable. For example, myNumber = 100 , 000 Will actually cause python to think that your number is of type tuple , which is a data type that doesn't allow you to change its value. To tell python that the number is still an integer you can do this: my_number = 100_00","title":"Variables and Data Types"},{"location":"python-tutorials/lesson1/#printing","text":"Now, suppose I wanted to print the value of a variable as an output. Python has a useful function called print() for this, so print ( myNumber ) will output 100000 . If I wanted to combine a string with the number, all you need to do is pass another argument (what print() will print) to print() . print ( \"My number is \" , myNumber ) Output: My number is 100000 One more thing: what if we wanted to format a string into different parts i.e. number here, string there without using commas? Python allows us to do this super easily too: print ( f \"My number is { myNumber } \" ) Output: My number is 100000 Python recognizes that you wanted a formatted string by prefixing the string with an f . Then you can use curly braces to say where you want the number! (You'll see how awesome this is in future lessons).","title":"Printing"},{"location":"python-tutorials/lesson1/#strings","text":"Say I wanted to give my favorite world a name, and hold that name in a variable. I could do it like this: minecraft_world_name = \"Zombie manhunt\" And in this case, the variable would be of type string . In python, strings are neat because you can add characters to them like this: my_name = \"Bill\" my_full_name = my_name + \" Mitchell\" print ( my_full_name ) Output: Bill Mitchell There are also some cool methods to modify strings: upper() Makes a string uppercase rock = \"let's rock\" print ( rock . upper ()) Output: LET'S ROCK lower() Makes a string lowercase fruit = \"APPLES\" print ( fruit . lower ()) Output: apples title() Capitalizes a string my_name = \"bill mitchell\" print ( my_name . title ()) Output: Bill Mitchell","title":"Strings"},{"location":"python-tutorials/lesson1/#booleans","text":"One more example: suppose I wanted to say whether python is cool. I could use a boolean type variable: python_is_awesome = True","title":"Booleans"},{"location":"python-tutorials/lesson1/#type-function","text":"If you ever want to know what the type of something is, then you can use a function called type() . This outputs the type of the variable: print ( type ( 1 )) print ( type ( 1.1 )) print ( type ( 1000000000 )) print ( type ( \"one\" )) print ( type ([ 1 , 2 , 3 , 4 ])) # Coming next lesson! Output: < type 'int' > < type 'float' > < type 'int' > < type 'str' > < type 'list' >","title":"Type Function"},{"location":"python-tutorials/lesson1/#basic-arithmetic","text":"So... pure variables are boring - you've probably figured that out by now. Can we modify them? In fact, yes! And it's super easy. Whenever you modify a variable, python essentially overrides one of the variables. Say I just made a new minecraft world. To add another world, I'd just do: minecraft_world_count = minecraft_world_count + 1 Super easy! Since programmers use this kind of arithmetic very often, however, there is shorthand notation for this: minecraft_world_count += 1 += # variable = variable + increment -= # variable = variable - increment *= # variable = variable * increment /= # variable = variable / increment","title":"Basic Arithmetic"},{"location":"python-tutorials/lesson1/#commenting","text":"What if you have code and you want to write a description about it? Just writing next to it won't work because python will think that you're still trying to code. In this case, you can use comments . Simply prefix any words/sentences/phrases with a hashtag: # . For bulk commenting, you can use three quotes. Example: # My name is Zephyr: print ( \"My name is Zephyr!\" ) \"\"\" Do you like striders in minecraft? I do... they are fun, but could use more health. On a scale of 1-10, this is how much I like striders: \"\"\" print ( 7 )","title":"Commenting"},{"location":"python-tutorials/lesson2/","text":"Lists, Sets, Dictionaries, and Tuples Created By: Sean Boerhout Lists We've already learned about variables, which allow us to store data in different chunks of memory. But what if there are a whole bunch of varaibles that are actually related to each other? Suppose I wanted to list my favorite animals. I could do it like this: my_favorite_animal1 = \"Tiger\" my_favorite_animal2 = \"Turtle\" my_favorite_animal3 = \"Elephant\" my_favorite_animal4 = \"Dolphin\" But this isn't very nice; the variables are essentially all the same, except holding my next favorite animal. To make this more readable, we can use a list . my_favorite_animals = [ \"Tiger\" , \"Turtle\" , \"Elephant\" , \"Dolphin\" ] # ^ You must use brackets ^ The cool thing about this is that there is no need to have a bunch of variables, because all the data is essentially held in one. Indexing But how do I get each variable out? For that, we need to talk about index . The index of one of each item in a list is where it lies in the list. It's super simple; the first item in the list has an index of 0, and the rest have an index of 1 + (previous index). For the example above, \"Tiger\" has an index of 0, \"Turtle\" has an index of 1, etc. my_most_favorite_animal = my_favorite_animals [ 0 ] # Tigers print ( my_most_favorite_animal ) Output: Tiger You can also use a negative number as an index... what do you think this means? my_least_favorite_animal = my_favorite_animals [ - 1 ] print ( my_least_favorite_animal ) Output: Dolphin That's right! Negative numbers start form the back of the list. We can also use colons, to specify a range: print ( my_favorite_animals [:]) print ( my_favorite_animals [ 0 : 3 ]) print ( my_favorite_animals [ 1 :]) print ( my_favorite_animals [: 3 ]) print ( my_favorite_animals [: - 1 ]) Output: [ 'Tiger' , 'Turtle' , 'Elephant' , 'Dolphin' ] [ 'Tiger' , 'Turtle' , 'Elephant' ] [ 'Turtle' , 'Elephant' , 'Dolphin' ] [ 'Tiger' , 'Turtle' , 'Elephant' ] [ 'Tiger' , 'Turtle' , 'Elephant' ] Each number on the sides of the colon specify the start/endpoints of the range of numbers. The number in front of the colon will always be included, the number behind the colon won't be included (but the number before it will). Modifying Elements Like normal variables, you can also override certain elements in a list: my_favorite_animals = [ \"Tiger\" , \"Turtle\" , \"Elephant\" , \"Dolphin\" ] # original my_favorite_animals [ 0 ] = \"blue whale\" print ( my_favorite_animals ) Output: [ 'blue whale' , 'Turtle' , 'Elephant' , 'Dolphin' ] And you can do basic arithmetic with them too! Strings print ( \"My favorite animal is \" + my_favorite_animals [ 0 ]) Output: My favorite animal is blue whale Numbers bananas_every_day = [ 2 , 1 , 1 , 3 , 2 , 5 , 6 ] print ( \"I ate \" , bananas_every_day [ 1 ] + bananas_every_day [ 2 ], \" bananas on Monday and Tuesday\" ) Output: I ate 2 bananas on Monday and Tuesday Useful Methods There are also some cool methods that can be used to modify lists: append() Adds an element to the end of a list my_favorite_animals . append ( \"Hyena\" ) print ( my_favorite_animals ) Output: [ 'Tiger' , 'Turtle' , 'Elephant' , 'Dolphin' , 'Hyena' ] pop() removes an element from a list and returns its output print ( my_favorite_animals . pop ( 0 )) # remove Tiger print ( my_favorite_animals ) Output: Tiger [ 'Turtle' , 'Elephant' , 'Dolphin' , 'hyena' ] insert() Allows you to insert a value at a specified index fruits = [ \"apples\" , \"oranges\" , \"lemons\" ] fruits . insert ( 0 , \"grapes\" ) print ( fruits ) Output: [ 'grapes' , 'apples' , 'oranges' , 'lemons' ] Multi-dimensional lists You can also put lists in other lists: my_favorite_ocean_animals = [ \"Tiger Shark\" , \"Sea Turtle\" , \"Dolphin\" ] my_favorite_animals = [ my_favorite_ocean_animals , \"Tortoise\" , \"Elephant\" ] print ( my_favorite_animals ) Output: [[ 'Tiger Shark' , 'Sea Turtle' , 'Dolphin' ], 'Tortoise' , 'Elephant' ] And access elements inside the list inside the list print ( \"My favorite sea creature is \" , my_favorite_animals [ 0 ][ 0 ]) Output: Tiger Shark Sets Sets are just like lists, but have three main exceptions: Every element must be unique They don't preserve their order No indexing (since they have no order!) Let's compare them with some examples. making_cereal_list = [ \"Put cereal in bowl\" , \"Put milk in bowl\" , \"Eat!\" ] # This is a list making_cereal_set = { \"Put cereal in bowl\" , \"Put milk in bowl\" , \"Eat!\" } # This is a set # ^ Sets use curly braces ^ print ( making_cereal_list ) print ( making_cereal_set ) Output: [ 'Put cereal in bowl' , 'Put milk in bowl' , 'Eat!' ] { 'Eat!' , 'Put cereal in bowl' , 'Put milk in bowl' } What? Eat the cereal before putting it in your bowl? That doesn't makes sense! Let's see how sets stay unique: making_cereal_list = [ \"Put cereal in bowl\" , \"Put milk in bowl\" , \"Eat!\" , \"Eat!\" , \"Eat!\" ] # This is a list making_cereal_set = { \"Put cereal in bowl\" , \"Put milk in bowl\" , \"Eat!\" , \"Eat!\" , \"Eat!\" } # This is a list print ( making_cereal_list ) print ( making_cereal_set ) Output: [ 'Put cereal in bowl' , 'Put milk in bowl' , 'Eat!' , 'Eat!' , 'Eat!' ] { 'Eat!' , 'Put milk in bowl' , 'Put cereal in bowl' } As you can see, there is only one \"Eat!\" in the set, but three in the list. Useful Methods Here are the counterparts to append() and pop() but for sets: add() Adds an element to a set (no particular order) candy_types = { \"Twix\" , \"Airhead\" , \"Kit Kat\" } candy_types . add ( \"Skittles\" ) Output: { 'Twix' , 'Kit Kat' , 'Skittles' , 'Airhead' } remove() removes an element from a set candy_types = { \"Twix\" , \"Airhead\" , \"Kit Kat\" } candy_types . remove ( \"Twix\" ) Output: { 'Kit Kat' , 'Airhead' } Dictionaries Dictionaries are like lists with some extra features. They allow you to associate a name to a value in a structured manner: about_me = { 'name' : 'Zephyr' , 'food' : 'fish' , 'siblings' : 5 , 'species' : 'cat' } print ( about_me ) print ( about_me [ 'name' ]) print ( about_me [ 'siblings' ]) Output: {'species': 'cat', 'food': 'fish', 'siblings': 5, 'name': 'Zephyr'} Zephyr 5 This can make your code more easy to understand because the index of an element has a custom name. If you wanted to, however, you could make the key of an element (the name denoted to its index) a number: size_chart = { 1 : 5 2 : 10 } print ( size_chart [ 1 ]) Output: 5 Modifying dictionaries Here are the counterparts to append() and pop() but for dictionaries: Adding data In dictionaries, it is super easy to add data! Just make a new key with its own value: cookies = { \"smell\" : \"delicious\" , \"type\" : \"Chocolate\" } cookies [ \"taste\" ] = \"amazing\" print ( cookies ) Output: { 'type' : 'Chocolate' , 'smell' : 'delicious' , 'taste' : 'amazing' } del deletes a key and value from a dictionary pies = { \"apple\" : \"good\" , \"pumpkin\" : \"terrible\" } del pies [ \"pumpkin\" ] print ( pies ) Output: { 'apple' : 'good' } Useful methods keys() returns all the keys of a dictionary in the form of a list course = { \"language\" : \"python\" , \"students\" : 100_000 , \"Instructor\" : \"WV Arduino Club\" } keys = course . keys () print ( keys ) Output: dict_keys ([ 'language' , 'Instructor' , 'students' ]) values() returns all the values of a dictionary in the form of a list course = { \"language\" : \"python\" , \"students\" : 100_000 , \"Instructor\" : \"WV Arduino Club\" } values = course . values () print ( values ) Output: dict_values ([ 'python' , 'WV Arduino Club' , 100000 ]) items() returns the items of the dictionary as a list You can use a for loop to access the list as such: course = { \"language\" : \"python\" , \"Instructor\" : \"WV Arduino Club\" } for key , values in course . items (): print ( f \"The course { key } is { value } \" ) Output: The course Instructor is WV Arduino Club The course language is python Tuples Tuples are nearly axactly like a list, but they can't be modified. Like lists, they also mainting their order (Sets don't!). Also, indexing works exactly the same way: chemistry_consts = ( 6.022 , 2.998 , 6.626 ) # ^ Tuples use parens ^ print ( chemistry_consts [ 0 ]) Output: 6.022 As mentioned, you can't modify them: chemistry_consts = ( 6.022 , 2.998 , 6.626 ) chemistry_consts . append ( 8.314 ) Output: Line 2 : AttributeError : 'tuple' object has no attribute 'append' That's an error! The append() method doesn't exist for tuples! Instead, we can create new tuples that have the elements we want from old tuples. chemistry_consts = ( 6.022 , 2.998 , 6.626 ) updated_chemistry_consts = chemistry_consts [ 0 : 2 ] print ( updated_chemistry_consts ) Output: (6.022, 2.998) Useful methods What can we do to tuples? count() returns number of times a value is in a certain tuple chemistry_consts = ( 6.022 , 2.998 , 6.626 , 2.998 ) print ( chemistry_consts . count ( 2.998 )) print ( chemistry_consts . count ( 6.022 )) Output: 2 1 index() returns index of a the first instance of a certain item in the tuple chemistry_consts = ( 6.022 , 2.998 , 6.626 , 2.998 ) print ( chemistry_consts . index ( 2.998 )) print ( chemistry_consts . index ( 6.022 )) Output: 1 0","title":"Lists, Sets, Dictionaries, and Tuples"},{"location":"python-tutorials/lesson2/#lists-sets-dictionaries-and-tuples","text":"Created By: Sean Boerhout","title":"Lists, Sets, Dictionaries, and Tuples"},{"location":"python-tutorials/lesson2/#lists","text":"We've already learned about variables, which allow us to store data in different chunks of memory. But what if there are a whole bunch of varaibles that are actually related to each other? Suppose I wanted to list my favorite animals. I could do it like this: my_favorite_animal1 = \"Tiger\" my_favorite_animal2 = \"Turtle\" my_favorite_animal3 = \"Elephant\" my_favorite_animal4 = \"Dolphin\" But this isn't very nice; the variables are essentially all the same, except holding my next favorite animal. To make this more readable, we can use a list . my_favorite_animals = [ \"Tiger\" , \"Turtle\" , \"Elephant\" , \"Dolphin\" ] # ^ You must use brackets ^ The cool thing about this is that there is no need to have a bunch of variables, because all the data is essentially held in one.","title":"Lists"},{"location":"python-tutorials/lesson2/#indexing","text":"But how do I get each variable out? For that, we need to talk about index . The index of one of each item in a list is where it lies in the list. It's super simple; the first item in the list has an index of 0, and the rest have an index of 1 + (previous index). For the example above, \"Tiger\" has an index of 0, \"Turtle\" has an index of 1, etc. my_most_favorite_animal = my_favorite_animals [ 0 ] # Tigers print ( my_most_favorite_animal ) Output: Tiger You can also use a negative number as an index... what do you think this means? my_least_favorite_animal = my_favorite_animals [ - 1 ] print ( my_least_favorite_animal ) Output: Dolphin That's right! Negative numbers start form the back of the list. We can also use colons, to specify a range: print ( my_favorite_animals [:]) print ( my_favorite_animals [ 0 : 3 ]) print ( my_favorite_animals [ 1 :]) print ( my_favorite_animals [: 3 ]) print ( my_favorite_animals [: - 1 ]) Output: [ 'Tiger' , 'Turtle' , 'Elephant' , 'Dolphin' ] [ 'Tiger' , 'Turtle' , 'Elephant' ] [ 'Turtle' , 'Elephant' , 'Dolphin' ] [ 'Tiger' , 'Turtle' , 'Elephant' ] [ 'Tiger' , 'Turtle' , 'Elephant' ] Each number on the sides of the colon specify the start/endpoints of the range of numbers. The number in front of the colon will always be included, the number behind the colon won't be included (but the number before it will).","title":"Indexing"},{"location":"python-tutorials/lesson2/#modifying-elements","text":"Like normal variables, you can also override certain elements in a list: my_favorite_animals = [ \"Tiger\" , \"Turtle\" , \"Elephant\" , \"Dolphin\" ] # original my_favorite_animals [ 0 ] = \"blue whale\" print ( my_favorite_animals ) Output: [ 'blue whale' , 'Turtle' , 'Elephant' , 'Dolphin' ] And you can do basic arithmetic with them too! Strings print ( \"My favorite animal is \" + my_favorite_animals [ 0 ]) Output: My favorite animal is blue whale Numbers bananas_every_day = [ 2 , 1 , 1 , 3 , 2 , 5 , 6 ] print ( \"I ate \" , bananas_every_day [ 1 ] + bananas_every_day [ 2 ], \" bananas on Monday and Tuesday\" ) Output: I ate 2 bananas on Monday and Tuesday","title":"Modifying Elements"},{"location":"python-tutorials/lesson2/#useful-methods","text":"There are also some cool methods that can be used to modify lists: append() Adds an element to the end of a list my_favorite_animals . append ( \"Hyena\" ) print ( my_favorite_animals ) Output: [ 'Tiger' , 'Turtle' , 'Elephant' , 'Dolphin' , 'Hyena' ] pop() removes an element from a list and returns its output print ( my_favorite_animals . pop ( 0 )) # remove Tiger print ( my_favorite_animals ) Output: Tiger [ 'Turtle' , 'Elephant' , 'Dolphin' , 'hyena' ] insert() Allows you to insert a value at a specified index fruits = [ \"apples\" , \"oranges\" , \"lemons\" ] fruits . insert ( 0 , \"grapes\" ) print ( fruits ) Output: [ 'grapes' , 'apples' , 'oranges' , 'lemons' ]","title":"Useful Methods"},{"location":"python-tutorials/lesson2/#multi-dimensional-lists","text":"You can also put lists in other lists: my_favorite_ocean_animals = [ \"Tiger Shark\" , \"Sea Turtle\" , \"Dolphin\" ] my_favorite_animals = [ my_favorite_ocean_animals , \"Tortoise\" , \"Elephant\" ] print ( my_favorite_animals ) Output: [[ 'Tiger Shark' , 'Sea Turtle' , 'Dolphin' ], 'Tortoise' , 'Elephant' ] And access elements inside the list inside the list print ( \"My favorite sea creature is \" , my_favorite_animals [ 0 ][ 0 ]) Output: Tiger Shark","title":"Multi-dimensional lists"},{"location":"python-tutorials/lesson2/#sets","text":"Sets are just like lists, but have three main exceptions: Every element must be unique They don't preserve their order No indexing (since they have no order!) Let's compare them with some examples. making_cereal_list = [ \"Put cereal in bowl\" , \"Put milk in bowl\" , \"Eat!\" ] # This is a list making_cereal_set = { \"Put cereal in bowl\" , \"Put milk in bowl\" , \"Eat!\" } # This is a set # ^ Sets use curly braces ^ print ( making_cereal_list ) print ( making_cereal_set ) Output: [ 'Put cereal in bowl' , 'Put milk in bowl' , 'Eat!' ] { 'Eat!' , 'Put cereal in bowl' , 'Put milk in bowl' } What? Eat the cereal before putting it in your bowl? That doesn't makes sense! Let's see how sets stay unique: making_cereal_list = [ \"Put cereal in bowl\" , \"Put milk in bowl\" , \"Eat!\" , \"Eat!\" , \"Eat!\" ] # This is a list making_cereal_set = { \"Put cereal in bowl\" , \"Put milk in bowl\" , \"Eat!\" , \"Eat!\" , \"Eat!\" } # This is a list print ( making_cereal_list ) print ( making_cereal_set ) Output: [ 'Put cereal in bowl' , 'Put milk in bowl' , 'Eat!' , 'Eat!' , 'Eat!' ] { 'Eat!' , 'Put milk in bowl' , 'Put cereal in bowl' } As you can see, there is only one \"Eat!\" in the set, but three in the list.","title":"Sets"},{"location":"python-tutorials/lesson2/#useful-methods_1","text":"Here are the counterparts to append() and pop() but for sets: add() Adds an element to a set (no particular order) candy_types = { \"Twix\" , \"Airhead\" , \"Kit Kat\" } candy_types . add ( \"Skittles\" ) Output: { 'Twix' , 'Kit Kat' , 'Skittles' , 'Airhead' } remove() removes an element from a set candy_types = { \"Twix\" , \"Airhead\" , \"Kit Kat\" } candy_types . remove ( \"Twix\" ) Output: { 'Kit Kat' , 'Airhead' }","title":"Useful Methods"},{"location":"python-tutorials/lesson2/#dictionaries","text":"Dictionaries are like lists with some extra features. They allow you to associate a name to a value in a structured manner: about_me = { 'name' : 'Zephyr' , 'food' : 'fish' , 'siblings' : 5 , 'species' : 'cat' } print ( about_me ) print ( about_me [ 'name' ]) print ( about_me [ 'siblings' ]) Output: {'species': 'cat', 'food': 'fish', 'siblings': 5, 'name': 'Zephyr'} Zephyr 5 This can make your code more easy to understand because the index of an element has a custom name. If you wanted to, however, you could make the key of an element (the name denoted to its index) a number: size_chart = { 1 : 5 2 : 10 } print ( size_chart [ 1 ]) Output: 5","title":"Dictionaries"},{"location":"python-tutorials/lesson2/#modifying-dictionaries","text":"Here are the counterparts to append() and pop() but for dictionaries: Adding data In dictionaries, it is super easy to add data! Just make a new key with its own value: cookies = { \"smell\" : \"delicious\" , \"type\" : \"Chocolate\" } cookies [ \"taste\" ] = \"amazing\" print ( cookies ) Output: { 'type' : 'Chocolate' , 'smell' : 'delicious' , 'taste' : 'amazing' } del deletes a key and value from a dictionary pies = { \"apple\" : \"good\" , \"pumpkin\" : \"terrible\" } del pies [ \"pumpkin\" ] print ( pies ) Output: { 'apple' : 'good' }","title":"Modifying dictionaries"},{"location":"python-tutorials/lesson2/#useful-methods_2","text":"keys() returns all the keys of a dictionary in the form of a list course = { \"language\" : \"python\" , \"students\" : 100_000 , \"Instructor\" : \"WV Arduino Club\" } keys = course . keys () print ( keys ) Output: dict_keys ([ 'language' , 'Instructor' , 'students' ]) values() returns all the values of a dictionary in the form of a list course = { \"language\" : \"python\" , \"students\" : 100_000 , \"Instructor\" : \"WV Arduino Club\" } values = course . values () print ( values ) Output: dict_values ([ 'python' , 'WV Arduino Club' , 100000 ]) items() returns the items of the dictionary as a list You can use a for loop to access the list as such: course = { \"language\" : \"python\" , \"Instructor\" : \"WV Arduino Club\" } for key , values in course . items (): print ( f \"The course { key } is { value } \" ) Output: The course Instructor is WV Arduino Club The course language is python","title":"Useful methods"},{"location":"python-tutorials/lesson2/#tuples","text":"Tuples are nearly axactly like a list, but they can't be modified. Like lists, they also mainting their order (Sets don't!). Also, indexing works exactly the same way: chemistry_consts = ( 6.022 , 2.998 , 6.626 ) # ^ Tuples use parens ^ print ( chemistry_consts [ 0 ]) Output: 6.022 As mentioned, you can't modify them: chemistry_consts = ( 6.022 , 2.998 , 6.626 ) chemistry_consts . append ( 8.314 ) Output: Line 2 : AttributeError : 'tuple' object has no attribute 'append' That's an error! The append() method doesn't exist for tuples! Instead, we can create new tuples that have the elements we want from old tuples. chemistry_consts = ( 6.022 , 2.998 , 6.626 ) updated_chemistry_consts = chemistry_consts [ 0 : 2 ] print ( updated_chemistry_consts ) Output: (6.022, 2.998)","title":"Tuples"},{"location":"python-tutorials/lesson2/#useful-methods_3","text":"What can we do to tuples? count() returns number of times a value is in a certain tuple chemistry_consts = ( 6.022 , 2.998 , 6.626 , 2.998 ) print ( chemistry_consts . count ( 2.998 )) print ( chemistry_consts . count ( 6.022 )) Output: 2 1 index() returns index of a the first instance of a certain item in the tuple chemistry_consts = ( 6.022 , 2.998 , 6.626 , 2.998 ) print ( chemistry_consts . index ( 2.998 )) print ( chemistry_consts . index ( 6.022 )) Output: 1 0","title":"Useful methods"},{"location":"python-tutorials/lesson3/","text":"A Quick Recap Created By: Sean Boerhout Here I'll give you a quick recap of what you've learned in the form of an example. Suppose I wanted user input at a vending machine, where customers need to type in the drink that they want. Using a dictionary, I can easily relate the name of that drink to a price: drink_prices = { \"sprite\" : 2.50 , \"coke\" : 2.00 , \"fanta\" : 3.00 } In order to get the user's input, I'll use a cool function called input() . It prompts python to ask for your input and assigns the input to a string: customer_drink = input () Now we can ask someone for their desired drink and tell them the price! customer_drink = input () print ( drink_prices [ customer_drink ]) But we can do better than that... let's make the process more friendly with some print() s. print ( \"Welcome! What drink would you like? Please choose from one of the choices below:\" ) print ( drink_prices . keys ()) # ask them for their drink and say the price customer_drink = input () print ( f \" { customer_drink . title () } s costs { drink_prices [ customer_drink ] } dollars!\" ) But, wait. What if the user makes a typo by using the wrong capitalization? We can ensure that the input is always read correctly: customer_drink = input () . lower () Since all the keys in our dictionary are lowercase, this will fix that problem. Finished Code Here's all that code put together: drink_prices = { \"sprite\" : 2.50 , \"coke\" : 2.00 , \"fanta\" : 3.00 } print ( \"Welcome! What drink would you like? Please choose from one of the choices below:\" ) print ( drink_prices . keys ()) customer_drink = input () . lower () print ( f \" { customer_drink . title () } s costs { drink_prices [ customer_drink ] } dollars!\" ) Try it yourself Challenge Create a fictional character that a user can learn about! You should use at least one dictionary, one input, and one list. Here is an example:","title":"A quick recap"},{"location":"python-tutorials/lesson3/#a-quick-recap","text":"Created By: Sean Boerhout Here I'll give you a quick recap of what you've learned in the form of an example. Suppose I wanted user input at a vending machine, where customers need to type in the drink that they want. Using a dictionary, I can easily relate the name of that drink to a price: drink_prices = { \"sprite\" : 2.50 , \"coke\" : 2.00 , \"fanta\" : 3.00 } In order to get the user's input, I'll use a cool function called input() . It prompts python to ask for your input and assigns the input to a string: customer_drink = input () Now we can ask someone for their desired drink and tell them the price! customer_drink = input () print ( drink_prices [ customer_drink ]) But we can do better than that... let's make the process more friendly with some print() s. print ( \"Welcome! What drink would you like? Please choose from one of the choices below:\" ) print ( drink_prices . keys ()) # ask them for their drink and say the price customer_drink = input () print ( f \" { customer_drink . title () } s costs { drink_prices [ customer_drink ] } dollars!\" ) But, wait. What if the user makes a typo by using the wrong capitalization? We can ensure that the input is always read correctly: customer_drink = input () . lower () Since all the keys in our dictionary are lowercase, this will fix that problem.","title":"A Quick Recap"},{"location":"python-tutorials/lesson3/#finished-code","text":"Here's all that code put together: drink_prices = { \"sprite\" : 2.50 , \"coke\" : 2.00 , \"fanta\" : 3.00 } print ( \"Welcome! What drink would you like? Please choose from one of the choices below:\" ) print ( drink_prices . keys ()) customer_drink = input () . lower () print ( f \" { customer_drink . title () } s costs { drink_prices [ customer_drink ] } dollars!\" )","title":"Finished Code"},{"location":"python-tutorials/lesson3/#try-it-yourself","text":"","title":"Try it yourself"},{"location":"python-tutorials/lesson3/#challenge","text":"Create a fictional character that a user can learn about! You should use at least one dictionary, one input, and one list. Here is an example:","title":"Challenge"},{"location":"python-tutorials/lesson4/","text":"If Statements and Operators Created By: Sean Boerhout Ok, I'll admit it. So far, everything has a been a little boring. Time to add some conditions to our code! The if statement is crucial to being able to program, and it exists in nearly every programming language. It allows you to make comparisons in the nature of: if this, then that . Here's an example: if 1 == 1 : print ( \"one equals one\" ); Output: one equals one As you can see, in the example above, a comparison is being made between the value of 1 and 1 . Since they were equal to each other, the if statement continued to the next line, which is in its scope . We'll get to scope a little later. Operators If you're wondering why the if statement requires double equal signs ( == ), its because it is an operator . Operators are special symbols that perform an arithmetic, comprison, or logical operation (in this case, comparison). Some of these you already know! Arithmetic Operators 2 + 2 = 4 (+, addition operator) 3 - 2 = 1 (-, subtraction operator) 2 * 1 = 2 (*, multiplication operator) 2 / 1 = 2 (/, the division operator) 2 ** 3 = 8 (**, the exponent operator) 5 % 2 = 1 (%, the modulus operator) 13 // 5 = 3 (//, the floor division operator) Comparison Operators 3 > 2 (>, the greater than operator) 4 < 5 (<, the less than operator) 4 == 4 (==, the equal to operator) 5 != 6 (!=, the not equal operator) 5 >=5 (>=, the greater than or equal to operator) 6 <= 7 (<=, the less than or equal to operator) Logical Operators and returns True when something and something else are true x = True y = True print ( x and y ) Output: True or returns True when something or something else is true x = True y = False print ( x or y ) Output: True not returns the complement (opposite value of) of a variable x = True print ( not x ) Output: False Now let's look at some more examples of if statements. your_age = 40 if your_Age >= 21 : print ( \"You can drink alcohol\" ); Output: You can drink alcohol your_name = \"Lars\" if your_name != \"Zephyr\" : print ( \"You aren't my cat!\" ); Output: You aren't my cat! Else There is another cool thing we can do with if statements, however. What if we want to do something if an if statement isn't triggered? Well, for that we can use the else statement: your_name = \"Zephyr\" if your_name != \"Zephyr\" : print ( \"You aren't my cat!\" ); else : print ( \"You are my cat!\" ) Output: You are my cat! Elif Additionally, you may want to go into another if statement if an else is triggered. For that, we have teh `elif statement, which stands for \"else if\". name = \"Sean\" if name == \"Jonathan\" : print ( \"You are my friend\" ) elif name == \"Andrew\" : print ( \"You are my best friend\" ) elif name == \"Sean\" : print ( \"You are me!\" ) else : print ( \"Who are you??\" ) Output: You are me! Notice that the else and the elif statements must come after an if statement. Scope But how do we organize what is in the if statement and what isn't? Well, we do that with scope . By indenting with a tab, python will be able to determine what code is a part of other code: x = True if x : # this will always happen because the condition is true! print ( \"This is in the if statement\" ) print ( \"This is also in the if statement\" ) print ( \"This too!\" ) print ( \"This is not in the if statement\" ) Output: This is in the if statement This is also in the if statement This too! This is not in the if statement The same thing goes for else and elif statements.","title":"If Statements and Operators"},{"location":"python-tutorials/lesson4/#if-statements-and-operators","text":"Created By: Sean Boerhout Ok, I'll admit it. So far, everything has a been a little boring. Time to add some conditions to our code! The if statement is crucial to being able to program, and it exists in nearly every programming language. It allows you to make comparisons in the nature of: if this, then that . Here's an example: if 1 == 1 : print ( \"one equals one\" ); Output: one equals one As you can see, in the example above, a comparison is being made between the value of 1 and 1 . Since they were equal to each other, the if statement continued to the next line, which is in its scope . We'll get to scope a little later.","title":"If Statements and Operators"},{"location":"python-tutorials/lesson4/#operators","text":"If you're wondering why the if statement requires double equal signs ( == ), its because it is an operator . Operators are special symbols that perform an arithmetic, comprison, or logical operation (in this case, comparison). Some of these you already know!","title":"Operators"},{"location":"python-tutorials/lesson4/#arithmetic-operators","text":"2 + 2 = 4 (+, addition operator) 3 - 2 = 1 (-, subtraction operator) 2 * 1 = 2 (*, multiplication operator) 2 / 1 = 2 (/, the division operator) 2 ** 3 = 8 (**, the exponent operator) 5 % 2 = 1 (%, the modulus operator) 13 // 5 = 3 (//, the floor division operator)","title":"Arithmetic Operators"},{"location":"python-tutorials/lesson4/#comparison-operators","text":"3 > 2 (>, the greater than operator) 4 < 5 (<, the less than operator) 4 == 4 (==, the equal to operator) 5 != 6 (!=, the not equal operator) 5 >=5 (>=, the greater than or equal to operator) 6 <= 7 (<=, the less than or equal to operator)","title":"Comparison Operators"},{"location":"python-tutorials/lesson4/#logical-operators","text":"and returns True when something and something else are true x = True y = True print ( x and y ) Output: True or returns True when something or something else is true x = True y = False print ( x or y ) Output: True not returns the complement (opposite value of) of a variable x = True print ( not x ) Output: False Now let's look at some more examples of if statements. your_age = 40 if your_Age >= 21 : print ( \"You can drink alcohol\" ); Output: You can drink alcohol your_name = \"Lars\" if your_name != \"Zephyr\" : print ( \"You aren't my cat!\" ); Output: You aren't my cat!","title":"Logical Operators"},{"location":"python-tutorials/lesson4/#else","text":"There is another cool thing we can do with if statements, however. What if we want to do something if an if statement isn't triggered? Well, for that we can use the else statement: your_name = \"Zephyr\" if your_name != \"Zephyr\" : print ( \"You aren't my cat!\" ); else : print ( \"You are my cat!\" ) Output: You are my cat!","title":"Else"},{"location":"python-tutorials/lesson4/#elif","text":"Additionally, you may want to go into another if statement if an else is triggered. For that, we have teh `elif statement, which stands for \"else if\". name = \"Sean\" if name == \"Jonathan\" : print ( \"You are my friend\" ) elif name == \"Andrew\" : print ( \"You are my best friend\" ) elif name == \"Sean\" : print ( \"You are me!\" ) else : print ( \"Who are you??\" ) Output: You are me! Notice that the else and the elif statements must come after an if statement.","title":"Elif"},{"location":"python-tutorials/lesson4/#scope","text":"But how do we organize what is in the if statement and what isn't? Well, we do that with scope . By indenting with a tab, python will be able to determine what code is a part of other code: x = True if x : # this will always happen because the condition is true! print ( \"This is in the if statement\" ) print ( \"This is also in the if statement\" ) print ( \"This too!\" ) print ( \"This is not in the if statement\" ) Output: This is in the if statement This is also in the if statement This too! This is not in the if statement The same thing goes for else and elif statements.","title":"Scope"},{"location":"python-tutorials/lesson5/","text":"For and While loops Created By: Sean Boerhout Suppose we have a list of strings and want to perform an operation involving every element of that string; maybe, printing out the names of everyone in a school classroom: students = [ \"Suzie\" , \"Ayush\" , \"David\" , \"Sid\" , \"Brian\" ] We could do it by explicitly printing out every element of the list: print ( students [ 0 ]) print ( students [ 1 ]) print ( students [ 2 ]) print ( students [ 3 ]) print ( students [ 4 ]) Output: Suzie Ayush David Sid Brian But this can become much more complicated as the operations being performed on/with the elements in the list become more complex. A good example is something with a 2d array (an array that holds other arrays): math_students = [ \"Sean\" , \"Brian\" ] literature_students = [ \"Justin\" , \"Ava\" ] all_students = [ math_students , literature_students ] print ( all_students [ 0 ][ 0 ]) # The first index is for the host array (all_students), print ( all_students [ 0 ][ 1 ]) # the second index is for the array inside the host print ( all_students [ 1 ][ 0 ]) # (math_students or literature_students) print ( all_students [ 1 ][ 1 ]) Output: Sean Brian Justin Ava What we'd really like to do is perform the same explicit operation but to different indexes of the array. You could imagine a solution to this quite easily; simply have the same code involving the index of an array, but increase the index automatically. That's what a loop can do! For Loops For Loops allow you to repeat something for a set number of iterations. Let's take a look at some real examples. for x in range ( 0 , 10 ): print ( x ) Output: 0 1 2 3 4 5 6 7 8 9 in can be a very useful for looping a set number of times. It assigns x to every element in a list, set, dictionary, etc. there are no more elements. That means that you can loop the number of times x could be assigned to something! Note that the variable doesn't need to be x; it can be anything. Python makes a new local variable (to be used inside the for loop) for whatever name you choose to assign the variable. In the case above, x is assigned to every output of range() . range() counts up in increments of one starting at the first argument and ending at the last argument. Note that it includes the first argument but not the last. Let's apply this new knowledge to the issues illustrated above. students = [ \"Suzie\" , \"Ayush\" , \"David\" , \"Sid\" , \"Brian\" ] for student in students : print ( student ) Output: Suzie Ayush David Sid Brian Simple, right? Using the range() function, we could've done the same thing this way: students = [ \"Suzie\" , \"Ayush\" , \"David\" , \"Sid\" , \"Brian\" ] for x in range ( 0 , len ( students )): # len() returns the number of indexes in the list print ( students [ x ]) Output: Suzie Ayush David Sid Brian Both cases are 3 lines of code, while the solution at the top using many print() statements involves 6! Nested Loops Let's go back to the 2d array problem. Notice that what we want to do is iterate through every index of a nested list, which is an index of another list itself. Basically, we want to loop through the indexes of the host array, but while were in each index of that array, loop again. This can be solved with two loops inside each other: math_students = [ \"Sean\" , \"Brian\" ] literature_students = [ \"Justin\" , \"Ava\" ] all_students = [ math_students , literature_students ] for student_subject in all_students : for student in student_subject : print ( student ) Output: Sean Brian Justin Ava Scope Scope in python is always the same; whatever is indented falls under the domain of the line above it with one less indentation. Thus, scope for loops is exactly the same as it is for if statements, which was explained in the previous lesson . That's why the 2d array example above works: since the nested loop (second one) falls under the scope of the first, student_subject can be accessed and iterated over by the second loop. Useful stuff Don't forget the stuff from other lessons! That can be applied here too: students = [ \"Jose\" , \"Abigail\" , \"George\" ] for good_student in students [: 2 ]: print ( f \" { good_student } is a good student!\" ) Output: Jose is a good student! Abigail is a good student! While loops While loops are just like for loops in the sense that they also loop, however they loop until a condition is met. x = 0 while x < 10 : x += 1 print ( x ) Output: 1 2 3 4 5 6 7 8 9 10 Like an if statement, you can also add an else statement to run when the condition in the while loop is false. x = 0 while x < 10 : x += 1 print ( x ) else : print ( \"x is no longer less than 10\" ) Output: 1 2 3 4 5 6 7 8 9 10 The great thing about while loops that you can make your program essentially stop at one issue and wait/repeatedly attempt to resolve the issue. For Arduinos, for example, you can wait to print something to the Serial console until a serial connection has been established: // In void setup() Serial . begin ( 9600 ); // This is c++, not python, while ( ! Serial ) // but the concept of the while delay ( 10 ); // still applies. Serial . println ( \"Serial port open\" ); But this can also be a huge problem; you need to make sure that there is always a way to exit the while loop so that your program doesn't accidentally get stuck in it! It's possible that your program gets stuck in the while and never finishes... leaving you with a program that you can't stop! There are two solutions to this: 1. Create a way to change the while condition externally (outside the while) 2. Create the possibility for the while condition to change internally (inside the while) In python, the second will apply more often. It's as simple as this: number = 10 while number > 5 : # eventually, number will not be less than 5 number -= 1 Flow control What if something weird happens that forces us to stop a loop or reset an iteration of a loop? Well, we have the break and continue statements for that. Break Break statements terminate the loop that they are in. When your program hits a break statement, it immediately exits the loop it is in as if the loop finished its last iteration (in the case of for loops) or the loop condition became False (in the case of while loops). When you have nested loops, the break statement only terminates the loop it is directly in, not loops enclosing a loop the break is in. Breaks are most commonly used to signify an error, or respond to a change that requires the end of a repetitive function. for x in range ( 0 , 9 ): print ( x ) if x == 5 : break print ( \"The for loop looped 6 times\" ) Output: 0 1 2 3 4 5 The for loop looped 6 times Continue Continue statements end the current iteration of a loop without terminating it completely. If you raise a flag somewhere in your loop and don't want the rest of the loop to act on the flag, you may want to use a continue. x_greater_than_five = False for x in range ( 0 , 9 ): if x == 5 : x_greater_than_five = True # This is only used on the NEXT loop continue print ( f \"x is { x } . Is x greater than five? { x_greater_than_five } \" )","title":"For and While loops"},{"location":"python-tutorials/lesson5/#for-and-while-loops","text":"Created By: Sean Boerhout Suppose we have a list of strings and want to perform an operation involving every element of that string; maybe, printing out the names of everyone in a school classroom: students = [ \"Suzie\" , \"Ayush\" , \"David\" , \"Sid\" , \"Brian\" ] We could do it by explicitly printing out every element of the list: print ( students [ 0 ]) print ( students [ 1 ]) print ( students [ 2 ]) print ( students [ 3 ]) print ( students [ 4 ]) Output: Suzie Ayush David Sid Brian But this can become much more complicated as the operations being performed on/with the elements in the list become more complex. A good example is something with a 2d array (an array that holds other arrays): math_students = [ \"Sean\" , \"Brian\" ] literature_students = [ \"Justin\" , \"Ava\" ] all_students = [ math_students , literature_students ] print ( all_students [ 0 ][ 0 ]) # The first index is for the host array (all_students), print ( all_students [ 0 ][ 1 ]) # the second index is for the array inside the host print ( all_students [ 1 ][ 0 ]) # (math_students or literature_students) print ( all_students [ 1 ][ 1 ]) Output: Sean Brian Justin Ava What we'd really like to do is perform the same explicit operation but to different indexes of the array. You could imagine a solution to this quite easily; simply have the same code involving the index of an array, but increase the index automatically. That's what a loop can do!","title":"For and While loops"},{"location":"python-tutorials/lesson5/#for-loops","text":"For Loops allow you to repeat something for a set number of iterations. Let's take a look at some real examples. for x in range ( 0 , 10 ): print ( x ) Output: 0 1 2 3 4 5 6 7 8 9 in can be a very useful for looping a set number of times. It assigns x to every element in a list, set, dictionary, etc. there are no more elements. That means that you can loop the number of times x could be assigned to something! Note that the variable doesn't need to be x; it can be anything. Python makes a new local variable (to be used inside the for loop) for whatever name you choose to assign the variable. In the case above, x is assigned to every output of range() . range() counts up in increments of one starting at the first argument and ending at the last argument. Note that it includes the first argument but not the last. Let's apply this new knowledge to the issues illustrated above. students = [ \"Suzie\" , \"Ayush\" , \"David\" , \"Sid\" , \"Brian\" ] for student in students : print ( student ) Output: Suzie Ayush David Sid Brian Simple, right? Using the range() function, we could've done the same thing this way: students = [ \"Suzie\" , \"Ayush\" , \"David\" , \"Sid\" , \"Brian\" ] for x in range ( 0 , len ( students )): # len() returns the number of indexes in the list print ( students [ x ]) Output: Suzie Ayush David Sid Brian Both cases are 3 lines of code, while the solution at the top using many print() statements involves 6!","title":"For Loops"},{"location":"python-tutorials/lesson5/#nested-loops","text":"Let's go back to the 2d array problem. Notice that what we want to do is iterate through every index of a nested list, which is an index of another list itself. Basically, we want to loop through the indexes of the host array, but while were in each index of that array, loop again. This can be solved with two loops inside each other: math_students = [ \"Sean\" , \"Brian\" ] literature_students = [ \"Justin\" , \"Ava\" ] all_students = [ math_students , literature_students ] for student_subject in all_students : for student in student_subject : print ( student ) Output: Sean Brian Justin Ava","title":"Nested Loops"},{"location":"python-tutorials/lesson5/#scope","text":"Scope in python is always the same; whatever is indented falls under the domain of the line above it with one less indentation. Thus, scope for loops is exactly the same as it is for if statements, which was explained in the previous lesson . That's why the 2d array example above works: since the nested loop (second one) falls under the scope of the first, student_subject can be accessed and iterated over by the second loop.","title":"Scope"},{"location":"python-tutorials/lesson5/#useful-stuff","text":"Don't forget the stuff from other lessons! That can be applied here too: students = [ \"Jose\" , \"Abigail\" , \"George\" ] for good_student in students [: 2 ]: print ( f \" { good_student } is a good student!\" ) Output: Jose is a good student! Abigail is a good student!","title":"Useful stuff"},{"location":"python-tutorials/lesson5/#while-loops","text":"While loops are just like for loops in the sense that they also loop, however they loop until a condition is met. x = 0 while x < 10 : x += 1 print ( x ) Output: 1 2 3 4 5 6 7 8 9 10 Like an if statement, you can also add an else statement to run when the condition in the while loop is false. x = 0 while x < 10 : x += 1 print ( x ) else : print ( \"x is no longer less than 10\" ) Output: 1 2 3 4 5 6 7 8 9 10 The great thing about while loops that you can make your program essentially stop at one issue and wait/repeatedly attempt to resolve the issue. For Arduinos, for example, you can wait to print something to the Serial console until a serial connection has been established: // In void setup() Serial . begin ( 9600 ); // This is c++, not python, while ( ! Serial ) // but the concept of the while delay ( 10 ); // still applies. Serial . println ( \"Serial port open\" ); But this can also be a huge problem; you need to make sure that there is always a way to exit the while loop so that your program doesn't accidentally get stuck in it! It's possible that your program gets stuck in the while and never finishes... leaving you with a program that you can't stop! There are two solutions to this: 1. Create a way to change the while condition externally (outside the while) 2. Create the possibility for the while condition to change internally (inside the while) In python, the second will apply more often. It's as simple as this: number = 10 while number > 5 : # eventually, number will not be less than 5 number -= 1","title":"While loops"},{"location":"python-tutorials/lesson5/#flow-control","text":"What if something weird happens that forces us to stop a loop or reset an iteration of a loop? Well, we have the break and continue statements for that.","title":"Flow control"},{"location":"python-tutorials/lesson5/#break","text":"Break statements terminate the loop that they are in. When your program hits a break statement, it immediately exits the loop it is in as if the loop finished its last iteration (in the case of for loops) or the loop condition became False (in the case of while loops). When you have nested loops, the break statement only terminates the loop it is directly in, not loops enclosing a loop the break is in. Breaks are most commonly used to signify an error, or respond to a change that requires the end of a repetitive function. for x in range ( 0 , 9 ): print ( x ) if x == 5 : break print ( \"The for loop looped 6 times\" ) Output: 0 1 2 3 4 5 The for loop looped 6 times","title":"Break"},{"location":"python-tutorials/lesson5/#continue","text":"Continue statements end the current iteration of a loop without terminating it completely. If you raise a flag somewhere in your loop and don't want the rest of the loop to act on the flag, you may want to use a continue. x_greater_than_five = False for x in range ( 0 , 9 ): if x == 5 : x_greater_than_five = True # This is only used on the NEXT loop continue print ( f \"x is { x } . Is x greater than five? { x_greater_than_five } \" )","title":"Continue"},{"location":"python-tutorials/lesson6/","text":"Custom Functions Created By: Sean Boerhout Suppose that you wanted to do something complicated over and over again... not in the sense of looping through something often, but rather you want a snippet of code to run at many places around your program. I'll give you an example: I have two lists of numbers, and I want to added up all the numbers in them. numbers = [ 1 , 5 , 3 , 8 , 9 , 3 , 7 , 4 , 8 ] more_numbers = [ 6 , 2 , 6 , 9 , 3 , 6 , 8 , 4 , 6 , 8 , 9 , 3 , 6 , 4 , 0 , 2 ] Instead of using a bunch of explicit arithmetic, we can apply what we learned from the previous lesson to solve this problem: numbers_sum = 0 for x in numbers : numbers_sum += x print ( numbers_sum ) numbers_sum = 0 for x in more_numbers : numbers_sum += x print ( numbers_sum ) Output: 48 82 While this did solve the problem for both lists, notice that the only difference between the two for loops is the list we are iterating through. Since we had to explicitly define which list each for loop would sum, we needed two for loops. So how can we optimize this? Well, by making our code general and able to be applied to many different applications. This can be done with functions . Functions A function is a block of code that runs only when it is called and generally contains lengthy code. def my_function (): # Function code goes here print ( \"my_function was run!\" ) my_function () # function called here Output: my_function was run! Now, the code from above (with the lists) can be simplified a little bit, but not really. We can put the for loops in a function to minimize the length of computing the sum of a certain list, but since the list being summed must still be explicitly defined in our function, we'll need to use two functions. def sum_numbers (): numbers_sum = 0 for x in numbers : numbers_sum += x print ( numbers_sum ) def sum_more_numbers (): numbers_sum = 0 for x in more_numbers : numbers_sum += x print ( numbers_sum ) sum_numbers () sum_more_numbers () Output: 48 82 Notice that numbers_sum is the same in both functions. The variable name isn't deemed as repeating because variables initialized (declared and defined) in functions lie under the function's own scope (local). Arguments Anyway, how can we optimize this? Well, we can pass an argument , sometimes known as a parameter to the function. This allows the function to act on something that we know will change in multiple contexts. def my_function ( argument ): print ( argument ) my_function ( \"Hello\" ) Output: Hello When the function is run, whatever arguments you put in the paratheses get copied to new variables to be used in your function locally. This means that you are never directly modifying the variable you pass to the function, which means that you can pass different variables depending on what you want to do! Let's use this new knowledge to create a clean solution to the list summing problem. numbers = [ 1 , 5 , 3 , 8 , 9 , 3 , 7 , 4 , 8 ] more_numbers = [ 6 , 2 , 6 , 9 , 3 , 6 , 8 , 4 , 6 , 8 , 9 , 3 , 6 , 4 , 0 , 2 ] def sum_list ( list ): list_sum = 0 for number in list : list_sum += number print ( list_sum ) sum_list ( numbers ) sum_list ( more_numbers ) Output: 48 82 Perfect! Returns In the functions above, we printed out the output of the function, but what if wanted to hold the output of the function as a variable instead? We could use a global variable (accessible over the entire program) that is modified inside the function like this: list_sum = 0 def sum_list ( list ): for number in list : list_sum += number But then if we wanted to use the function multiple times, it would become confusing keep track of when list_sum is holding data from a certain function call. This is where return comes in. Instead of printing the output of the function, we can return it, essentially making the function data available to be stored by a variable. def sum_list ( list ): list_sum = 0 for number in list : list_sum += number return list_sum numbers_sum = sum_list ( numbers ) # store the return as a variable, or print ( numbers_sum ) print ( sum_list ( more_numbers )) # pass it to a function right away! The advantage of this becomes apparent when we want to perform an operation on the return of a function. Say we wanted to compute the sum of lists (like before), but also the sum of those sums. numbers = [ 1 , 5 , 3 , 8 , 9 , 3 , 7 , 4 , 8 ] more_numbers = [ 6 , 2 , 6 , 9 , 3 , 6 , 8 , 4 , 6 , 8 , 9 , 3 , 6 , 4 , 0 , 2 ] def sum_list ( list ): # same as before list_sum = 0 for number in list : list_sum += number return list_sum def sum_list_sums ( list1 , list2 ): return sum_list ( list1 ) + sum_list ( list2 ) print ( sum_list_sums ( numbers , more_numbers )) Output: 130 With functions, we can create highly optimized and clean code. Since they can be applied to any arguments we specify (just of the correct type), it is much easier to write code using functions since there is less typing (thus less room for mistakes), but modifications to a function can be applied throughout your code, whereever you have called it. Fun fact: The function sum_list(list) created above is a built in function called sum() . If you ever want to sum a list, just use that.","title":"Custom functions"},{"location":"python-tutorials/lesson6/#custom-functions","text":"Created By: Sean Boerhout Suppose that you wanted to do something complicated over and over again... not in the sense of looping through something often, but rather you want a snippet of code to run at many places around your program. I'll give you an example: I have two lists of numbers, and I want to added up all the numbers in them. numbers = [ 1 , 5 , 3 , 8 , 9 , 3 , 7 , 4 , 8 ] more_numbers = [ 6 , 2 , 6 , 9 , 3 , 6 , 8 , 4 , 6 , 8 , 9 , 3 , 6 , 4 , 0 , 2 ] Instead of using a bunch of explicit arithmetic, we can apply what we learned from the previous lesson to solve this problem: numbers_sum = 0 for x in numbers : numbers_sum += x print ( numbers_sum ) numbers_sum = 0 for x in more_numbers : numbers_sum += x print ( numbers_sum ) Output: 48 82 While this did solve the problem for both lists, notice that the only difference between the two for loops is the list we are iterating through. Since we had to explicitly define which list each for loop would sum, we needed two for loops. So how can we optimize this? Well, by making our code general and able to be applied to many different applications. This can be done with functions .","title":"Custom Functions"},{"location":"python-tutorials/lesson6/#functions","text":"A function is a block of code that runs only when it is called and generally contains lengthy code. def my_function (): # Function code goes here print ( \"my_function was run!\" ) my_function () # function called here Output: my_function was run! Now, the code from above (with the lists) can be simplified a little bit, but not really. We can put the for loops in a function to minimize the length of computing the sum of a certain list, but since the list being summed must still be explicitly defined in our function, we'll need to use two functions. def sum_numbers (): numbers_sum = 0 for x in numbers : numbers_sum += x print ( numbers_sum ) def sum_more_numbers (): numbers_sum = 0 for x in more_numbers : numbers_sum += x print ( numbers_sum ) sum_numbers () sum_more_numbers () Output: 48 82 Notice that numbers_sum is the same in both functions. The variable name isn't deemed as repeating because variables initialized (declared and defined) in functions lie under the function's own scope (local).","title":"Functions"},{"location":"python-tutorials/lesson6/#arguments","text":"Anyway, how can we optimize this? Well, we can pass an argument , sometimes known as a parameter to the function. This allows the function to act on something that we know will change in multiple contexts. def my_function ( argument ): print ( argument ) my_function ( \"Hello\" ) Output: Hello When the function is run, whatever arguments you put in the paratheses get copied to new variables to be used in your function locally. This means that you are never directly modifying the variable you pass to the function, which means that you can pass different variables depending on what you want to do! Let's use this new knowledge to create a clean solution to the list summing problem. numbers = [ 1 , 5 , 3 , 8 , 9 , 3 , 7 , 4 , 8 ] more_numbers = [ 6 , 2 , 6 , 9 , 3 , 6 , 8 , 4 , 6 , 8 , 9 , 3 , 6 , 4 , 0 , 2 ] def sum_list ( list ): list_sum = 0 for number in list : list_sum += number print ( list_sum ) sum_list ( numbers ) sum_list ( more_numbers ) Output: 48 82 Perfect!","title":"Arguments"},{"location":"python-tutorials/lesson6/#returns","text":"In the functions above, we printed out the output of the function, but what if wanted to hold the output of the function as a variable instead? We could use a global variable (accessible over the entire program) that is modified inside the function like this: list_sum = 0 def sum_list ( list ): for number in list : list_sum += number But then if we wanted to use the function multiple times, it would become confusing keep track of when list_sum is holding data from a certain function call. This is where return comes in. Instead of printing the output of the function, we can return it, essentially making the function data available to be stored by a variable. def sum_list ( list ): list_sum = 0 for number in list : list_sum += number return list_sum numbers_sum = sum_list ( numbers ) # store the return as a variable, or print ( numbers_sum ) print ( sum_list ( more_numbers )) # pass it to a function right away! The advantage of this becomes apparent when we want to perform an operation on the return of a function. Say we wanted to compute the sum of lists (like before), but also the sum of those sums. numbers = [ 1 , 5 , 3 , 8 , 9 , 3 , 7 , 4 , 8 ] more_numbers = [ 6 , 2 , 6 , 9 , 3 , 6 , 8 , 4 , 6 , 8 , 9 , 3 , 6 , 4 , 0 , 2 ] def sum_list ( list ): # same as before list_sum = 0 for number in list : list_sum += number return list_sum def sum_list_sums ( list1 , list2 ): return sum_list ( list1 ) + sum_list ( list2 ) print ( sum_list_sums ( numbers , more_numbers )) Output: 130 With functions, we can create highly optimized and clean code. Since they can be applied to any arguments we specify (just of the correct type), it is much easier to write code using functions since there is less typing (thus less room for mistakes), but modifications to a function can be applied throughout your code, whereever you have called it. Fun fact: The function sum_list(list) created above is a built in function called sum() . If you ever want to sum a list, just use that.","title":"Returns"},{"location":"python-tutorials/lesson7/","text":"Libraries and Modules Created By: Sean Boerhout Nearly all programming language have libraries, or collections of code that perform a very specific task and are available to the public to use. For example, python's random library allows you to get random numbers, lists of numbers, and more, while faker allows you to get fake data about fake people, like a random name, address, email account, or country. While those libraries may seem niche and somewhat useless, nearly all projects require a library for something since they can be so powerful. numpy , for example, is an extremely powerful in math-related functions. tensorflow does machine learning. If you aren't using an ide that has a library built in, you may need to install it onto your computer with pip installer . Generally, libraries will give you the intructions to install them on their website Importing and Basic use Let's get started! Libraries are essentially large collections of code, just like anything you'd write. With the import function, you can essentially copy-paste that code. import random Functions associated with a library must be shown to be linked to a library. For example, random has a method (a function made accessible by a class , which we'll learn more about later) which returns a random number between a given range called randint() . We can call it like this: import random random_number = random . randint ( 0 , 9 ) Notice that randint(0, 9) is prefixed by a random. . This denotes the fact that randint() is defined by the random library and not by you. You might not always want to use the name of the library to prefix the method, however. To optimize this, you can use as : import random as rdm random_number = rdm . randint ( 0 , 9 ) That's about it with libraries! If you want to konw the syntax of a function or what a function does, a quick google search for the documentation of the library would probably be the best course of action.","title":"Libraries and Modules"},{"location":"python-tutorials/lesson7/#libraries-and-modules","text":"Created By: Sean Boerhout Nearly all programming language have libraries, or collections of code that perform a very specific task and are available to the public to use. For example, python's random library allows you to get random numbers, lists of numbers, and more, while faker allows you to get fake data about fake people, like a random name, address, email account, or country. While those libraries may seem niche and somewhat useless, nearly all projects require a library for something since they can be so powerful. numpy , for example, is an extremely powerful in math-related functions. tensorflow does machine learning. If you aren't using an ide that has a library built in, you may need to install it onto your computer with pip installer . Generally, libraries will give you the intructions to install them on their website","title":"Libraries and Modules"},{"location":"python-tutorials/lesson7/#importing-and-basic-use","text":"Let's get started! Libraries are essentially large collections of code, just like anything you'd write. With the import function, you can essentially copy-paste that code. import random Functions associated with a library must be shown to be linked to a library. For example, random has a method (a function made accessible by a class , which we'll learn more about later) which returns a random number between a given range called randint() . We can call it like this: import random random_number = random . randint ( 0 , 9 ) Notice that randint(0, 9) is prefixed by a random. . This denotes the fact that randint() is defined by the random library and not by you. You might not always want to use the name of the library to prefix the method, however. To optimize this, you can use as : import random as rdm random_number = rdm . randint ( 0 , 9 ) That's about it with libraries! If you want to konw the syntax of a function or what a function does, a quick google search for the documentation of the library would probably be the best course of action.","title":"Importing and Basic use"},{"location":"python-tutorials/lesson8/","text":"Putting it All Together Created By: Sean Boerhout Alright, now let's put our skills to the test with a quick challenge. Write a program that lets the user pick a number between 1 and 100. The program will try to guess the number after you tell it whether it's too high or too low. If the player wins the game, they should also be able to play again. It should work something like this: Here's a hint: To allow your program to come up with a random number, import random in your code. Then, use randint() to get a random integer between some 2 numbers: import random random_number = random . randint ( 0 , 10 ) # a random number between 0 and 10! Try making it in your ide! You can even use this interactive console: Can't figure it out? Here is the answer .","title":"Putting it All Together"},{"location":"python-tutorials/lesson8/#putting-it-all-together","text":"Created By: Sean Boerhout Alright, now let's put our skills to the test with a quick challenge. Write a program that lets the user pick a number between 1 and 100. The program will try to guess the number after you tell it whether it's too high or too low. If the player wins the game, they should also be able to play again. It should work something like this: Here's a hint: To allow your program to come up with a random number, import random in your code. Then, use randint() to get a random integer between some 2 numbers: import random random_number = random . randint ( 0 , 10 ) # a random number between 0 and 10! Try making it in your ide! You can even use this interactive console: Can't figure it out? Here is the answer .","title":"Putting it All Together"}]}